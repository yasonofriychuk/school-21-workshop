
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yasonofriychuk/tinvest-balancer/cmd/service/main.go (0.0%)</option>
				
				<option value="file1">github.com/yasonofriychuk/tinvest-balancer/internal/app/app.go (0.0%)</option>
				
				<option value="file2">github.com/yasonofriychuk/tinvest-balancer/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/yasonofriychuk/tinvest-balancer/internal/generated/api/portfolio_create/handler.gen.go (0.0%)</option>
				
				<option value="file4">github.com/yasonofriychuk/tinvest-balancer/internal/generated/api/routers.gen.go (0.0%)</option>
				
				<option value="file5">github.com/yasonofriychuk/tinvest-balancer/internal/handler/post_portfolio_create/handler.go (88.9%)</option>
				
				<option value="file6">github.com/yasonofriychuk/tinvest-balancer/internal/middleware/auth/middleware.go (0.0%)</option>
				
				<option value="file7">github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/convertor/error.go (0.0%)</option>
				
				<option value="file8">github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/error.go (0.0%)</option>
				
				<option value="file9">github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/service.go (0.0%)</option>
				
				<option value="file10">github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/user_service_client/client.go (0.0%)</option>
				
				<option value="file11">github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/utils.go (0.0%)</option>
				
				<option value="file12">github.com/yasonofriychuk/tinvest-balancer/internal/testcontainer/postgres/container.go (0.0%)</option>
				
				<option value="file13">github.com/yasonofriychuk/tinvest-balancer/internal/usecase/portfolio_create/contract_mock.go (0.0%)</option>
				
				<option value="file14">github.com/yasonofriychuk/tinvest-balancer/internal/usecase/portfolio_create/storage.go (0.0%)</option>
				
				<option value="file15">github.com/yasonofriychuk/tinvest-balancer/internal/usecase/portfolio_create/usecase.go (0.0%)</option>
				
				<option value="file16">github.com/yasonofriychuk/tinvest-balancer/pkg/cerrors/cerrors.go (0.0%)</option>
				
				<option value="file17">github.com/yasonofriychuk/tinvest-balancer/pkg/crypt/crypt.go (0.0%)</option>
				
				<option value="file18">github.com/yasonofriychuk/tinvest-balancer/pkg/crypt/util.go (0.0%)</option>
				
				<option value="file19">github.com/yasonofriychuk/tinvest-balancer/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file20">github.com/yasonofriychuk/tinvest-balancer/pkg/logger/logger_context.go (0.0%)</option>
				
				<option value="file21">github.com/yasonofriychuk/tinvest-balancer/pkg/migrate/migrate.go (0.0%)</option>
				
				<option value="file22">github.com/yasonofriychuk/tinvest-balancer/pkg/postgres/postgres.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "os/signal"

        "github.com/yasonofriychuk/tinvest-balancer/internal/app"
)

func main() <span class="cov0" title="0">{
        if err := realMain(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func realMain() error <span class="cov0" title="0">{
        ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
        defer cancel()

        if err := app.Run(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "github.com/go-chi/chi/v5"
        "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        "github.com/rs/cors"
        "github.com/yasonofriychuk/tinvest-balancer/internal/config"
        "github.com/yasonofriychuk/tinvest-balancer/internal/generated/api"
        "github.com/yasonofriychuk/tinvest-balancer/internal/handler/post_portfolio_create"
        "github.com/yasonofriychuk/tinvest-balancer/internal/middleware/auth"
        "github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest"
        "github.com/yasonofriychuk/tinvest-balancer/internal/usecase/portfolio_create"
        "github.com/yasonofriychuk/tinvest-balancer/pkg/crypt"
        "github.com/yasonofriychuk/tinvest-balancer/pkg/logger"
        "github.com/yasonofriychuk/tinvest-balancer/pkg/migrate"
        "github.com/yasonofriychuk/tinvest-balancer/pkg/postgres"
        "golang.org/x/sync/errgroup"
        "log/slog"
        "net/http"
        "os"
        "time"
)

func Run(ctx context.Context) error <span class="cov0" title="0">{
        cfg := config.MustNewConfig()

        log := logger.NewLogger(slog.LevelDebug, cfg.Env, os.Stdout)
        db := postgres.MustNew(cfg.DSN)

        if err := migrate.Migrate(cfg.DSN, "file://migrations"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("migrate.Migrate: %w", err)
        }</span>

        <span class="cov0" title="0">crypter := crypt.MustNew(crypt.MustKeyFromBase64(cfg.CryptKey))
        authMW := auth.NewAuthMiddleware()
        tinvestService := tinvest.MustNew(log, "@tinvest_balancer_bot")
        defer func(tinvestService *tinvest.Service) </span><span class="cov0" title="0">{ _ = tinvestService.Stop() }</span>(tinvestService)

        <span class="cov0" title="0">portfolioCreateUsecase := portfolio_create.New(portfolio_create.NewStorage(db), crypter, tinvestService)

        router := chi.NewRouter()
        router.Route("/api", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(authMW.Handler)
                api.Routers{
                        PortfolioCreate: post_portfolio_create.New(log, portfolioCreateUsecase),
                }.Register(r, []nethttp.StrictHTTPMiddlewareFunc{})
        }</span>)

        <span class="cov0" title="0">s := http.Server{
                Addr:              ":" + cfg.ServerPort,
                Handler:           cors.New(cors.Options{AllowedOrigins: []string{}}).Handler(router),
                ReadHeaderTimeout: time.Minute * 5,
        }

        errorGroup, _ := errgroup.WithContext(ctx)
        errorGroup.Go(func() (err error) </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                log.WithContext(ctx).Info("shutting down server")
                if err := s.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("s.Shutdown(): %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">errorGroup.Go(func() (err error) </span><span class="cov0" title="0">{
                log.WithContext(ctx).WithFields(map[string]any{
                        "addr": s.Addr,
                }).Info("starting server")

                if err := s.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        return fmt.Errorf("s.ListenAndServe(): %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err := errorGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("errorGroup.Wait(): %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"

        "github.com/joho/godotenv"
)

type Config struct {
        Env        string
        ServerPort string
        DSN        string
        CryptKey   string
}

func MustNewConfig() Config <span class="cov0" title="0">{
        _ = godotenv.Load()

        return Config{
                Env:        mustGetEnv("ENVIRONMENT"),
                ServerPort: mustGetEnv("HTTP_PORT"),
                DSN:        mustGetEnv("DATABASE_URL"),
                CryptKey:   mustGetEnv("CRYPT_KEY"),
        }
}</span>

func mustGetEnv(key string) string <span class="cov0" title="0">{
        value, ok := os.LookupEnv(key)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("environment variable %s not set", key))</span>
        }
        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package portfolio_create provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package portfolio_create

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/go-chi/chi/v5"
        strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// PostPortfolioCreateJSONBody defines parameters for PostPortfolioCreate.
type PostPortfolioCreateJSONBody struct {
        Token string `json:"token"`
}

// PostPortfolioCreateJSONRequestBody defines body for PostPortfolioCreate for application/json ContentType.
type PostPortfolioCreateJSONRequestBody PostPortfolioCreateJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {

        // (POST /portfolio/create)
        PostPortfolioCreate(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// (POST /portfolio/create)
func (_ Unimplemented) PostPortfolioCreate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusNotImplemented)
}</span>

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler            ServerInterface
        HandlerMiddlewares []MiddlewareFunc
        ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PostPortfolioCreate operation middleware
func (siw *ServerInterfaceWrapper) PostPortfolioCreate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PostPortfolioCreate(w, r)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

type UnescapedCookieParamError struct {
        ParamName string
        Err       error
}

func (e *UnescapedCookieParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}</span>

func (e *UnescapedCookieParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type UnmarshalingParamError struct {
        ParamName string
        Err       error
}

func (e *UnmarshalingParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}</span>

func (e *UnmarshalingParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type RequiredParamError struct {
        ParamName string
}

func (e *RequiredParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}</span>

type RequiredHeaderError struct {
        ParamName string
        Err       error
}

func (e *RequiredHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}</span>

func (e *RequiredHeaderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type InvalidParamFormatError struct {
        ParamName string
        Err       error
}

func (e *InvalidParamFormatError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}</span>

func (e *InvalidParamFormatError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type TooManyValuesForParamError struct {
        ParamName string
        Count     int
}

func (e *TooManyValuesForParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}</span>

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, ChiServerOptions{})
}</span>

type ChiServerOptions struct {
        BaseURL          string
        BaseRouter       chi.Router
        Middlewares      []MiddlewareFunc
        ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, ChiServerOptions{
                BaseRouter: r,
        })
}</span>

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, ChiServerOptions{
                BaseURL:    baseURL,
                BaseRouter: r,
        })
}</span>

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler <span class="cov0" title="0">{
        r := options.BaseRouter

        if r == nil </span><span class="cov0" title="0">{
                r = chi.NewRouter()
        }</span>
        <span class="cov0" title="0">if options.ErrorHandlerFunc == nil </span><span class="cov0" title="0">{
                options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
        }
        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler:            si,
                HandlerMiddlewares: options.Middlewares,
                ErrorHandlerFunc:   options.ErrorHandlerFunc,
        }

        r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post(options.BaseURL+"/portfolio/create", wrapper.PostPortfolioCreate)
        }</span>)

        <span class="cov0" title="0">return r</span>
}

type PostPortfolioCreateRequestObject struct {
        Body *PostPortfolioCreateJSONRequestBody
}

type PostPortfolioCreateResponseObject interface {
        VisitPostPortfolioCreateResponse(w http.ResponseWriter) error
}

type PostPortfolioCreate200JSONResponse struct {
        Status string `json:"status"`
}

func (response PostPortfolioCreate200JSONResponse) VisitPostPortfolioCreateResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostPortfolioCreate400JSONResponse struct {
        Message string `json:"message"`
}

func (response PostPortfolioCreate400JSONResponse) VisitPostPortfolioCreateResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostPortfolioCreate403JSONResponse struct {
        Message string `json:"message"`
}

func (response PostPortfolioCreate403JSONResponse) VisitPostPortfolioCreateResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostPortfolioCreate500JSONResponse struct {
        Message string `json:"message"`
}

func (response PostPortfolioCreate500JSONResponse) VisitPostPortfolioCreateResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {

        // (POST /portfolio/create)
        PostPortfolioCreate(ctx context.Context, request PostPortfolioCreateRequestObject) (PostPortfolioCreateResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
        RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
        ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
                RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>,
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>,
        }}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
        options     StrictHTTPServerOptions
}

// PostPortfolioCreate operation middleware
func (sh *strictHandler) PostPortfolioCreate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var request PostPortfolioCreateRequestObject

        var body PostPortfolioCreateJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PostPortfolioCreate(ctx, request.(PostPortfolioCreateRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PostPortfolioCreate")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PostPortfolioCreateResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPostPortfolioCreateResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by scripts/gen_paths.sh; DO NOT EDIT.

package api

import (
        "github.com/go-chi/chi/v5"
        "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        portfolio_create "github.com/yasonofriychuk/tinvest-balancer/internal/generated/api/portfolio_create"
)

// Routers собирает реализации StrictServerInterface по каждому сгенерированному подпакету.
type Routers struct {
        PortfolioCreate portfolio_create.StrictServerInterface
}

// Register регистрирует все непустые реализации на роутере.
func (rs Routers) Register(r chi.Router, mws []nethttp.StrictHTTPMiddlewareFunc) <span class="cov0" title="0">{
        if rs.PortfolioCreate != nil </span><span class="cov0" title="0">{
                portfolio_create.HandlerFromMux(portfolio_create.NewStrictHandler(rs.PortfolioCreate, mws), r)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package post_portfolio_create

import (
        "context"

        "github.com/yasonofriychuk/tinvest-balancer/pkg/logger"

        "github.com/AlekSi/pointer"

        api "github.com/yasonofriychuk/tinvest-balancer/internal/generated/api/portfolio_create"
        "github.com/yasonofriychuk/tinvest-balancer/internal/middleware/auth"
        "github.com/yasonofriychuk/tinvest-balancer/pkg/cerrors"
)

type Handler struct {
        log                    logger.Log
        createPortfolioUsecase createPortfolioUsecase
}

func New(log logger.Log, createPortfolioUsecase createPortfolioUsecase) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                log:                    log,
                createPortfolioUsecase: createPortfolioUsecase,
        }
}</span>

func (h *Handler) PostPortfolioCreate(ctx context.Context, request api.PostPortfolioCreateRequestObject) (api.PostPortfolioCreateResponseObject, error) <span class="cov8" title="1">{
        userId, _ := auth.GetUserId(ctx)
        body := pointer.Get(request.Body)

        if err := h.createPortfolioUsecase.CreatePortfolio(
                ctx,
                userId,
                body.Token,
        ); err != nil </span><span class="cov8" title="1">{
                if cErr, ok := cerrors.AsUserError(err); ok </span><span class="cov0" title="0">{
                        return api.PostPortfolioCreate400JSONResponse{Message: cErr.Message()}, nil
                }</span>
                <span class="cov8" title="1">h.log.WithContext(ctx).WithError(err).WithFields(map[string]any{
                        "userId": userId,
                }).Error("failed to create portfolio")
                return api.PostPortfolioCreate500JSONResponse{Message: "Не удалось сохранить токен"}, nil</span>
        }

        <span class="cov8" title="1">return api.PostPortfolioCreate200JSONResponse{Status: "Успех"}, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "context"
        "net/http"
        "strconv"
)

type contextKey string

const userDataKey = contextKey("userData")

type Middleware struct{}

func NewAuthMiddleware() *Middleware <span class="cov0" title="0">{
        return &amp;Middleware{}
}</span>

func (m *Middleware) Handler(next http.Handler) http.Handler <span class="cov0" title="0">{
        // Заглушка для workshop
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                userId, err := strconv.ParseInt(r.Header.Get("Authorization"), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid authorization header", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r.WithContext(context.WithValue(r.Context(), userDataKey, userId)))</span>
        })
}

// GetUserId - вспомогательная функция для извлечения данных из контекста.
func GetUserId(ctx context.Context) (int64, bool) <span class="cov0" title="0">{
        data, ok := ctx.Value(userDataKey).(int64)
        return data, ok
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package convertor

import (
        "fmt"

        "github.com/yasonofriychuk/tinvest-balancer/pkg/cerrors"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func ConvertErr(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return cerrors.NewInternalError(fmt.Errorf("unknown non-grpc error: %w", err))
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.Unauthenticated:<span class="cov0" title="0">
                return cerrors.NewBusinessError(fmt.Errorf("invalid token: %s", st.Message()))</span>
        default:<span class="cov0" title="0">
                return cerrors.NewInternalError(st.Err())</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package tinvest

import (
        "fmt"

        "github.com/yasonofriychuk/tinvest-balancer/pkg/cerrors"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func ConvertErr(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                return cerrors.NewInternalError(fmt.Errorf("unknown non-grpc error: %w", err))
        }</span>

        <span class="cov0" title="0">switch st.Code() </span>{
        case codes.Unauthenticated:<span class="cov0" title="0">
                return cerrors.NewBusinessError(fmt.Errorf("invalid token: %s", st.Message()))</span>
        default:<span class="cov0" title="0">
                return cerrors.NewInternalError(st.Err())</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tinvest

import (
        "context"
        "crypto/tls"
        "fmt"
        "github.com/russianinvestments/invest-api-go-sdk/investgo"
        "github.com/russianinvestments/invest-api-go-sdk/retry"
        "github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/user_service_client"
        "github.com/yasonofriychuk/tinvest-balancer/pkg/logger"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/metadata"
        "time"
)

const (
        waitBetween   = 500 * time.Millisecond
        headerAppName = "x-app-name"
)

type Service struct {
        log  logger.Log
        conn *grpc.ClientConn
        *user_service_client.UsersServiceClient
}

func MustNew(log logger.Log, appName string) *Service <span class="cov0" title="0">{
        conn, err := newConn(investgo.Config{
                EndPoint:                      "invest-public-api.tinkoff.ru:443",
                AppName:                       appName,
                DisableResourceExhaustedRetry: false,
                DisableAllRetry:               false,
                MaxRetries:                    3,
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("create tinvest service failed: %v", err))</span>
        }

        <span class="cov0" title="0">return &amp;Service{
                log:                log,
                conn:               conn,
                UsersServiceClient: user_service_client.New(conn),
        }</span>
}

func (s *Service) Stop() error <span class="cov0" title="0">{
        return s.conn.Close()
}</span>

func newConn(conf investgo.Config) (*grpc.ClientConn, error) <span class="cov0" title="0">{
        var dialOpts []grpc.DialOption

        opts := []retry.CallOption{
                retry.WithCodes(codes.Unavailable, codes.Internal, codes.Canceled),
                retry.WithBackoff(retry.BackoffLinear(waitBetween)),
                retry.WithMax(3),
        }

        // при исчерпывании лимита запросов в минуту, нужно ждать дольше
        exhaustedOpts := []retry.CallOption{
                retry.WithCodes(codes.ResourceExhausted),
                retry.WithMax(conf.MaxRetries),
                retry.WithOnRetryCallback(func(ctx context.Context, attempt uint, err error) </span>{<span class="cov0" title="0">
                        // TODO тут можно добавить лог
                }</span>),
        }

        <span class="cov0" title="0">streamInterceptors := []grpc.StreamClientInterceptor{
                retry.StreamClientInterceptor(opts...),
                outgoingAppNameStreamInterceptor(conf.AppName),
        }

        var unaryInterceptors []grpc.UnaryClientInterceptor
        if conf.DisableResourceExhaustedRetry </span><span class="cov0" title="0">{
                unaryInterceptors = []grpc.UnaryClientInterceptor{
                        retry.UnaryClientInterceptor(opts...),
                        outgoingAppNameUnaryInterceptor(conf.AppName),
                }
        }</span> else<span class="cov0" title="0"> {
                unaryInterceptors = []grpc.UnaryClientInterceptor{
                        retry.UnaryClientInterceptor(opts...),
                        retry.UnaryClientInterceptorRE(exhaustedOpts...),
                        outgoingAppNameUnaryInterceptor(conf.AppName),
                }
        }</span>

        <span class="cov0" title="0">dialOpts = append(
                dialOpts,
                grpc.WithTransportCredentials(credentials.NewTLS(&amp;tls.Config{})), // nolint: gosec
                grpc.WithChainUnaryInterceptor(unaryInterceptors...),
                grpc.WithChainStreamInterceptor(streamInterceptors...),
        )

        conn, err := grpc.NewClient(conf.EndPoint, dialOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("grpc.NewClient: %w", err)
        }</span>

        <span class="cov0" title="0">return conn, nil</span>
}

func outgoingAppNameUnaryInterceptor(appName string) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                ctx = metadata.AppendToOutgoingContext(ctx, headerAppName, appName)
                return invoker(ctx, method, req, reply, cc, opts...)
        }</span>
}

func outgoingAppNameStreamInterceptor(appName string) grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                ctx = metadata.AppendToOutgoingContext(ctx, headerAppName, appName)
                return streamer(ctx, desc, cc, method, opts...)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package user_service_client

import (
        "context"
        "github.com/AlekSi/pointer"
        "github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/convertor"
        "google.golang.org/grpc/status"

        pb "github.com/russianinvestments/invest-api-go-sdk/proto"
        "github.com/samber/lo"
        "golang.org/x/oauth2"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/oauth"
        "google.golang.org/grpc/metadata"
)

type UsersServiceClient struct {
        pbClient pb.UsersServiceClient
}

func New(conn *grpc.ClientConn) *UsersServiceClient <span class="cov0" title="0">{
        return &amp;UsersServiceClient{
                pbClient: pb.NewUsersServiceClient(conn),
        }
}</span>

// GetAccounts - Метод получения счетов пользователя
func (us *UsersServiceClient) GetAccounts(ctx context.Context, token string, status AccountStatus) (GetAccountsResponse, error) <span class="cov0" title="0">{
        var header, trailer metadata.MD
        resp, err := us.pbClient.GetAccounts(
                ctx,
                &amp;pb.GetAccountsRequest{
                        Status: pointer.To(pb.AccountStatus(status)),
                },
                grpc.PerRPCCredentials(oauth.TokenSource{
                        TokenSource: oauth2.StaticTokenSource(&amp;oauth2.Token{AccessToken: token}),
                }),
                grpc.Header(&amp;header),
                grpc.Trailer(&amp;trailer),
        )
        if err != nil </span><span class="cov0" title="0">{
                header = trailer
        }</span>

        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                return GetAccountsResponse{}, convertor.ConvertErr(err)
        }</span>

        <span class="cov0" title="0">return GetAccountsResponse{
                Accounts: lo.FilterMap(resp.GetAccounts(), func(a *pb.Account, _ int) (Account, bool) </span><span class="cov0" title="0">{
                        if a == nil </span><span class="cov0" title="0">{
                                return Account{}, false
                        }</span>

                        <span class="cov0" title="0">return Account{
                                Id:          a.GetId(),
                                Name:        a.GetName(),
                                Type:        AccountType(a.GetType()),
                                AccessLevel: AccessLevel(a.GetAccessLevel()),
                                Status:      AccountStatus(a.GetStatus()),
                        }, true</span>
                }),
        }, err
}

// MarginIsEnabled - Проверка наличия включенной маржинальной торговли
func (us *UsersServiceClient) MarginIsEnabled(ctx context.Context, token string, accountId string) (bool, error) <span class="cov0" title="0">{
        _, err := us.pbClient.GetMarginAttributes(ctx, &amp;pb.GetMarginAttributesRequest{
                AccountId: accountId,
        }, grpc.PerRPCCredentials(oauth.TokenSource{
                TokenSource: oauth2.StaticTokenSource(&amp;oauth2.Token{AccessToken: token}),
        }))

        if s, ok := status.FromError(err); ok &amp;&amp; s != nil </span><span class="cov0" title="0">{
                if s.Message() == "30051" </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, convertor.ConvertErr(err)
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tinvest

import (
        investapi "github.com/russianinvestments/invest-api-go-sdk/proto"
        "github.com/shopspring/decimal"
)

type unitsNano interface {
        GetUnits() int64
        GetNano() int32
}

func ToDecimal(q unitsNano) decimal.Decimal <span class="cov0" title="0">{
        if q == nil </span><span class="cov0" title="0">{
                return decimal.Zero
        }</span>
        <span class="cov0" title="0">return decimal.NewFromInt(q.GetUnits()).Add(decimal.New(int64(q.GetNano()), -9))</span>
}

func FromDecimal(d decimal.Decimal) *investapi.Quotation <span class="cov0" title="0">{
        units := d.Truncate(0).IntPart()

        fractionalPart := d.Sub(decimal.NewFromInt(units))
        nanoDecimal := fractionalPart.Mul(decimal.New(1, 9))
        nano := int32(nanoDecimal.IntPart()) // nolint: gosec

        return &amp;investapi.Quotation{
                Units: units,
                Nano:  nano,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package postgres

import (
        "context"
        "fmt"
        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/modules/postgres"
        "github.com/yasonofriychuk/tinvest-balancer/pkg/migrate"
        postgres_db "github.com/yasonofriychuk/tinvest-balancer/pkg/postgres"
)

type Container struct {
        *postgres.PostgresContainer
}

func MustNew(ctx context.Context) Container <span class="cov0" title="0">{
        ctr, err := postgres.Run(
                ctx,
                "postgres:17-alpine",
                postgres.WithDatabase("master"),
                postgres.WithUsername("postgres"),
                postgres.WithPassword("password"),
                postgres.BasicWaitStrategies(),
                postgres.WithSQLDriver("pgx"),
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("postgres.Run: %w", err))</span>
        }

        <span class="cov0" title="0">dsnUrl, err := ctr.ConnectionString(ctx, "sslmode=disable")
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("ctr.ConnectionString: %w", err))</span>
        }

        <span class="cov0" title="0">if err := migrate.Migrate(dsnUrl, "file://../../../migrations"); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("migrate.Migrate: %w", err))</span>
        }

        <span class="cov0" title="0">if err := ctr.Snapshot(ctx); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("ctr.Snapshot(ctx): %w", err))</span>
        }

        <span class="cov0" title="0">return Container{
                PostgresContainer: ctr,
        }</span>
}

func (c *Container) GetDb(ctx context.Context) (*sqlx.DB, error) <span class="cov0" title="0">{
        dsnUrl, err := c.ConnectionString(ctx, "sslmode=disable")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("c.ConnectionString: %w", err)
        }</span>

        <span class="cov0" title="0">db, err := postgres_db.New(dsnUrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("postgres_db.New: %w", err)
        }</span>
        <span class="cov0" title="0">return db, nil</span>
}

func (c *Container) Terminate() error <span class="cov0" title="0">{
        return testcontainers.TerminateContainer(c.Container)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: contract.go
//
// Generated by this command:
//
//        mockgen -source=contract.go -destination contract_mock.go -package portfolio_create
//

// Package portfolio_create is a generated GoMock package.
package portfolio_create

import (
        context "context"
        reflect "reflect"

        user_service_client "github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/user_service_client"
        gomock "go.uber.org/mock/gomock"
)

// Mockstorage is a mock of storage interface.
type Mockstorage struct {
        ctrl     *gomock.Controller
        recorder *MockstorageMockRecorder
        isgomock struct{}
}

// MockstorageMockRecorder is the mock recorder for Mockstorage.
type MockstorageMockRecorder struct {
        mock *Mockstorage
}

// NewMockstorage creates a new mock instance.
func NewMockstorage(ctrl *gomock.Controller) *Mockstorage <span class="cov0" title="0">{
        mock := &amp;Mockstorage{ctrl: ctrl}
        mock.recorder = &amp;MockstorageMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockstorage) EXPECT() *MockstorageMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// setToken mocks base method.
func (m *Mockstorage) setToken(cxt context.Context, userId int64, accountId, name string, accountType int64, token string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "setToken", cxt, userId, accountId, name, accountType, token)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// setToken indicates an expected call of setToken.
func (mr *MockstorageMockRecorder) setToken(cxt, userId, accountId, name, accountType, token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "setToken", reflect.TypeOf((*Mockstorage)(nil).setToken), cxt, userId, accountId, name, accountType, token)
}</span>

// Mockcrypter is a mock of crypter interface.
type Mockcrypter struct {
        ctrl     *gomock.Controller
        recorder *MockcrypterMockRecorder
        isgomock struct{}
}

// MockcrypterMockRecorder is the mock recorder for Mockcrypter.
type MockcrypterMockRecorder struct {
        mock *Mockcrypter
}

// NewMockcrypter creates a new mock instance.
func NewMockcrypter(ctrl *gomock.Controller) *Mockcrypter <span class="cov0" title="0">{
        mock := &amp;Mockcrypter{ctrl: ctrl}
        mock.recorder = &amp;MockcrypterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockcrypter) EXPECT() *MockcrypterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Encrypt mocks base method.
func (m *Mockcrypter) Encrypt(text string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Encrypt", text)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Encrypt indicates an expected call of Encrypt.
func (mr *MockcrypterMockRecorder) Encrypt(text any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Encrypt", reflect.TypeOf((*Mockcrypter)(nil).Encrypt), text)
}</span>

// MocktInvestService is a mock of tInvestService interface.
type MocktInvestService struct {
        ctrl     *gomock.Controller
        recorder *MocktInvestServiceMockRecorder
        isgomock struct{}
}

// MocktInvestServiceMockRecorder is the mock recorder for MocktInvestService.
type MocktInvestServiceMockRecorder struct {
        mock *MocktInvestService
}

// NewMocktInvestService creates a new mock instance.
func NewMocktInvestService(ctrl *gomock.Controller) *MocktInvestService <span class="cov0" title="0">{
        mock := &amp;MocktInvestService{ctrl: ctrl}
        mock.recorder = &amp;MocktInvestServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktInvestService) EXPECT() *MocktInvestServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAccounts mocks base method.
func (m *MocktInvestService) GetAccounts(ctx context.Context, token string, status user_service_client.AccountStatus) (user_service_client.GetAccountsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAccounts", ctx, token, status)
        ret0, _ := ret[0].(user_service_client.GetAccountsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAccounts indicates an expected call of GetAccounts.
func (mr *MocktInvestServiceMockRecorder) GetAccounts(ctx, token, status any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccounts", reflect.TypeOf((*MocktInvestService)(nil).GetAccounts), ctx, token, status)
}</span>

// MarginIsEnabled mocks base method.
func (m *MocktInvestService) MarginIsEnabled(ctx context.Context, token, accountId string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MarginIsEnabled", ctx, token, accountId)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// MarginIsEnabled indicates an expected call of MarginIsEnabled.
func (mr *MocktInvestServiceMockRecorder) MarginIsEnabled(ctx, token, accountId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarginIsEnabled", reflect.TypeOf((*MocktInvestService)(nil).MarginIsEnabled), ctx, token, accountId)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package portfolio_create

import (
        "context"
        "fmt"
        "time"

        "github.com/jmoiron/sqlx"
)

type Storage struct {
        db  *sqlx.DB
        now func() time.Time
}

func NewStorage(db *sqlx.DB) *Storage <span class="cov0" title="0">{
        return &amp;Storage{
                db: db,
                now: func() time.Time </span><span class="cov0" title="0">{
                        return time.Now().UTC()
                }</span>,
        }
}

func (s *Storage) WithNowFunc(f func() time.Time) *Storage <span class="cov0" title="0">{
        if f != nil </span><span class="cov0" title="0">{
                s.now = f
        }</span>
        <span class="cov0" title="0">return s</span>
}

func (s *Storage) setToken(cxt context.Context, userId int64, accountId string, name string, accountType int64, token string) error <span class="cov0" title="0">{
        const query = `
                INSERT INTO portfolio 
                    (user_id, account_id, name, account_type, token, created_at, updated_at) 
                VALUES ($1, $2, $3, $4, $5, $6, $6)
                ON CONFLICT 
                    (user_id, account_id) 
                DO UPDATE 
                    SET token = EXCLUDED.token, 
                        name = EXCLUDED.name,
                        account_type = EXCLUDED.account_type,
                        updated_at = EXCLUDED.updated_at,
                        deleted_at = NULL,
                        auto_rebalancing_enabled = false
        `

        if _, err := s.db.ExecContext(cxt, query, userId, accountId, name, accountType, token, s.now()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("s.db.ExecContext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package portfolio_create

import (
        "context"
        "errors"
        "fmt"
        "github.com/yasonofriychuk/tinvest-balancer/internal/service/tinvest/user_service_client"
        "github.com/yasonofriychuk/tinvest-balancer/pkg/cerrors"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "slices"
)

type Usecase struct {
        s              storage
        crypter        crypter
        tInvestService tInvestService
}

func New(storage storage, crypter crypter, tInvestService tInvestService) *Usecase <span class="cov0" title="0">{
        return &amp;Usecase{
                s:              storage,
                crypter:        crypter,
                tInvestService: tInvestService,
        }
}</span>

func (u *Usecase) CreatePortfolio(ctx context.Context, userId int64, token string) error <span class="cov0" title="0">{
        // Проверка токена
        resp, err := u.tInvestService.GetAccounts(ctx, token, user_service_client.AccountStatus_ACCOUNT_STATUS_OPEN)
        if err != nil </span><span class="cov0" title="0">{
                if st, ok := status.FromError(err); ok &amp;&amp; st.Code() == codes.Unauthenticated </span><span class="cov0" title="0">{
                        return cerrors.NewUserError(err).WithMessage("Токен недействителен")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("u.tInvestService.GetAccounts: %w", err)</span>
        }

        <span class="cov0" title="0">if len(resp.Accounts) == 0 </span><span class="cov0" title="0">{
                return cerrors.NewUserError(errors.New("accounts is empty")).WithMessage("Нет доступных счетов")
        }</span>

        <span class="cov0" title="0">if len(resp.Accounts) &gt; 1 </span><span class="cov0" title="0">{
                return cerrors.NewUserError(errors.New("accounts more than 1")).WithMessage("Токен должен быть создан для одного счета")
        }</span>

        <span class="cov0" title="0">acc := resp.Accounts[0]
        if acc.AccessLevel != user_service_client.AccessLevel_ACCOUNT_ACCESS_LEVEL_FULL_ACCESS </span><span class="cov0" title="0">{
                return cerrors.NewUserError(errors.New("there are no accounts with full access")).WithMessage("Для совершения операций нужен токен с полным доступом")
        }</span>

        <span class="cov0" title="0">if !slices.Contains([]user_service_client.AccountType{
                user_service_client.AccountType_ACCOUNT_TYPE_TINKOFF, user_service_client.AccountType_ACCOUNT_TYPE_TINKOFF_IIS,
        }, acc.Type) </span><span class="cov0" title="0">{
                return cerrors.NewUserError(errors.New("incorrect account type")).WithMessage("Выставление ордеров для этого счета недоступно")
        }</span>

        <span class="cov0" title="0">if acc.Status != user_service_client.AccountStatus_ACCOUNT_STATUS_OPEN </span><span class="cov0" title="0">{
                return cerrors.NewUserError(errors.New("incorrect account status")).WithMessage("Счет закрыт")
        }</span>

        <span class="cov0" title="0">enabled, err := u.tInvestService.MarginIsEnabled(ctx, token, acc.Id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("u.tInvestService.GetMarginAttributes: %w", err)
        }</span>

        <span class="cov0" title="0">if enabled </span><span class="cov0" title="0">{
                return cerrors.NewUserError(errors.New("margin enabled")).WithMessage("Отключите маржинальную торговлю")
        }</span>

        // Шифрование и сохранение токена
        <span class="cov0" title="0">encryptedToken, err := u.crypter.Encrypt(token)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("u.crypter.Encrypt: %w", err)
        }</span>

        <span class="cov0" title="0">if err := u.s.setToken(ctx, userId, acc.Id, acc.Name, convertAccountType(acc.Type), encryptedToken); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("u.s.setToken: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func convertAccountType(tType user_service_client.AccountType) int64 <span class="cov0" title="0">{
        switch tType </span>{
        case user_service_client.AccountType_ACCOUNT_TYPE_TINKOFF:<span class="cov0" title="0">
                return 1</span>
        case user_service_client.AccountType_ACCOUNT_TYPE_TINKOFF_IIS:<span class="cov0" title="0">
                return 2</span>
        case user_service_client.AccountType_ACCOUNT_TYPE_INVEST_BOX:<span class="cov0" title="0">
                return 3</span>
        case user_service_client.AccountType_ACCOUNT_TYPE_INVEST_FUND:<span class="cov0" title="0">
                return 4</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cerrors

import (
        "errors"
        "fmt"
        "strconv"
        "strings"
)

type ErrorType string

const (
        UserError         ErrorType = "validation_error"
        InternalError     ErrorType = "internal_error"
        BusinessError     ErrorType = "business_error"
        UnauthorizedError ErrorType = "unauthorized_error"
)

type Error struct {
        Type     ErrorType
        Err      error
        messages []string
        params   map[string][]any
}

func New(errorType ErrorType, err error) Error <span class="cov0" title="0">{
        return Error{
                Type: errorType,
                Err:  err,
                params: map[string][]any{
                        "error_type": {errorType},
                },
        }
}</span>

func As(err error) (Error, bool) <span class="cov0" title="0">{
        var target Error
        if !errors.As(err, &amp;target) </span><span class="cov0" title="0">{
                return target, false
        }</span>
        <span class="cov0" title="0">return target, true</span>
}

func AsUserError(err error) (Error, bool) <span class="cov0" title="0">{
        return asTError(err, UserError)
}</span>

func AsBusinessError(err error) (Error, bool) <span class="cov0" title="0">{
        return asTError(err, BusinessError)
}</span>

func AsUnauthorizedErrorError(err error) (Error, bool) <span class="cov0" title="0">{
        return asTError(err, UnauthorizedError)
}</span>

func AsInternalError(err error) (Error, bool) <span class="cov0" title="0">{
        return asTError(err, InternalError)
}</span>

func asTError(err error, t ErrorType) (Error, bool) <span class="cov0" title="0">{
        var target Error
        if !errors.As(err, &amp;target) </span><span class="cov0" title="0">{
                return target, false
        }</span>

        <span class="cov0" title="0">if target.Type != t </span><span class="cov0" title="0">{
                return target, false
        }</span>

        <span class="cov0" title="0">return target, true</span>
}

func NewUserError(err error) Error <span class="cov0" title="0">{
        return New(UserError, err)
}</span>

func NewBusinessError(err error) Error <span class="cov0" title="0">{
        return New(BusinessError, err)
}</span>

func NewUnauthorizedError(err error) Error <span class="cov0" title="0">{
        return New(UnauthorizedError, err)
}</span>

func NewInternalError(err error) Error <span class="cov0" title="0">{
        return New(InternalError, err)
}</span>

func (v Error) WithParam(key string, value any) Error <span class="cov0" title="0">{
        v.params[key] = append(v.params[key], value)
        return v
}</span>

func (v Error) WithParams(params map[string]any) Error <span class="cov0" title="0">{
        for key, value := range params </span><span class="cov0" title="0">{
                v.params[key] = append(v.params[key], value)
        }</span>
        <span class="cov0" title="0">return v</span>
}

func (v Error) WithMessage(msg string) Error <span class="cov0" title="0">{
        v.messages = append(v.messages, msg)
        return v
}</span>

func (v Error) Message() string <span class="cov0" title="0">{
        return strings.Join(v.messages, "\n")
}</span>

func (v Error) Params() map[string]any <span class="cov0" title="0">{
        params := make(map[string]any, len(v.params))
        for key, values := range v.params </span><span class="cov0" title="0">{
                if len(values) == 1 </span><span class="cov0" title="0">{
                        params[key] = values[0]
                        continue</span>
                }

                <span class="cov0" title="0">for i, value := range values </span><span class="cov0" title="0">{
                        params[key+"_"+strconv.Itoa(i)] = value
                }</span>
        }
        <span class="cov0" title="0">return params</span>
}

func (v Error) Error() string <span class="cov0" title="0">{
        if v.Err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("[%s]: %s", v.Type, v.Err.Error())
        }</span>
        <span class="cov0" title="0">return "nil"</span>
}

func (v Error) Unwrap() error <span class="cov0" title="0">{
        return v.Err
}</span>

func (v Error) GetType() ErrorType <span class="cov0" title="0">{
        return v.Type
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package crypt

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "io"
)

type Crypter struct {
        gcm cipher.AEAD
}

func MustNew(key []byte) *Crypter <span class="cov0" title="0">{
        c, err := New(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return c</span>
}

func New(key []byte) (*Crypter, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("aes.NewCipher: %w", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cipher.NewGCM: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Crypter{gcm: gcm}, nil</span>
}

func (c *Crypter) Encrypt(text string) (string, error) <span class="cov0" title="0">{
        nonce := make([]byte, c.gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("nonce: %w", err)
        }</span>

        <span class="cov0" title="0">cipherText := c.gcm.Seal(nonce, nonce, []byte(text), nil)
        return base64.StdEncoding.EncodeToString(cipherText), nil</span>
}

func (c *Crypter) Decrypt(encoded string) (string, error) <span class="cov0" title="0">{
        data, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("base64 decode: %w", err)
        }</span>

        <span class="cov0" title="0">nonceSize := c.gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ciphertext too short")
        }</span>

        <span class="cov0" title="0">nonce, ciphertext := data[:nonceSize], data[nonceSize:]
        plain, err := c.gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("decrypt: %w", err)
        }</span>

        <span class="cov0" title="0">return string(plain), nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package crypt

import (
        "crypto/rand"
        "encoding/base64"
        "fmt"
)

func MustKeyFromBase64(key string) []byte <span class="cov0" title="0">{
        b, err := base64.StdEncoding.DecodeString(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to decode key: %s", err))</span>
        }

        <span class="cov0" title="0">if len(b) != 32 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invalid CRYPT_KEY length: got %d, want 32 bytes", len(key)))</span>
        }

        <span class="cov0" title="0">return b</span>
}

func GenerateBase64Key() (string, error) <span class="cov0" title="0">{
        key := make([]byte, 32)
        _, err := rand.Read(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random key: %w", err)
        }</span>

        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(key), nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package logger

import (
        "context"
        "io"
        "log/slog"
)

const (
        errKey    = "error"
        fieldsKey = "fields"
        envKey    = "env"
)

type Logger struct {
        log slogLogger
}

func NewLogger(level slog.Level, env string, source io.Writer) *Logger <span class="cov0" title="0">{
        handler := slog.NewJSONHandler(source, &amp;slog.HandlerOptions{
                Level:     level,
                AddSource: true,
        })

        return &amp;Logger{
                log: slog.New(handler).With(slog.String(envKey, env)).WithGroup(fieldsKey),
        }
}</span>

func (l *Logger) WithContext(ctx context.Context) LogCtx <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>

        <span class="cov0" title="0">return LogCtx{
                log: l.log,
                ctx: ctx,
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package logger

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "runtime"
        "time"
)

type LogCtx struct {
        log slogLogger
        ctx context.Context
}

func (l LogCtx) WithError(err error) LogCtx <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return l
        }</span>

        <span class="cov0" title="0">return LogCtx{
                log: l.log.With(slog.Any(errKey, err)),
                ctx: l.ctx,
        }</span>
}

func (l LogCtx) WithFields(fields map[string]any) LogCtx <span class="cov0" title="0">{
        var attrs []any

        for k, f := range fields </span><span class="cov0" title="0">{
                attrs = append(attrs, slog.Any(k, f))
        }</span>

        <span class="cov0" title="0">return LogCtx{
                log: l.log.With(attrs...),
                ctx: l.ctx,
        }</span>
}

func (l LogCtx) Debug(msg string) <span class="cov0" title="0">{
        if !l.log.Enabled(l.ctx, slog.LevelDebug) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var pcs [1]uintptr
        runtime.Callers(2, pcs[:])
        _ = l.log.Handler().Handle(l.ctx, slog.NewRecord(time.Now(), slog.LevelDebug, msg, pcs[0]))</span>
}

func (l LogCtx) Info(msg string) <span class="cov0" title="0">{
        if !l.log.Enabled(l.ctx, slog.LevelInfo) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var pcs [1]uintptr
        runtime.Callers(2, pcs[:])
        _ = l.log.Handler().Handle(l.ctx, slog.NewRecord(time.Now(), slog.LevelInfo, msg, pcs[0]))</span>
}

func (l LogCtx) Warning(msg string) <span class="cov0" title="0">{
        if !l.log.Enabled(l.ctx, slog.LevelWarn) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var pcs [1]uintptr
        runtime.Callers(2, pcs[:])
        _ = l.log.Handler().Handle(l.ctx, slog.NewRecord(time.Now(), slog.LevelWarn, msg, pcs[0]))</span>
}

func (l LogCtx) Error(msg string) <span class="cov0" title="0">{
        if !l.log.Enabled(l.ctx, slog.LevelError) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var pcs [1]uintptr
        runtime.Callers(2, pcs[:])
        _ = l.log.Handler().Handle(l.ctx, slog.NewRecord(time.Now(), slog.LevelError, msg, pcs[0]))</span>
}

func (l LogCtx) Infof(template string, args ...any) <span class="cov0" title="0">{
        if !l.log.Enabled(l.ctx, slog.LevelInfo) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var pcs [1]uintptr
        runtime.Callers(2, pcs[:])
        _ = l.log.Handler().Handle(l.ctx, slog.NewRecord(time.Now(), slog.LevelInfo, fmt.Sprintf(template, args...), pcs[0]))</span>
}

func (l LogCtx) Errorf(template string, args ...any) <span class="cov0" title="0">{
        if !l.log.Enabled(l.ctx, slog.LevelError) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var pcs [1]uintptr
        runtime.Callers(2, pcs[:])
        _ = l.log.Handler().Handle(l.ctx, slog.NewRecord(time.Now(), slog.LevelError, fmt.Sprintf(template, args...), pcs[0]))</span>
}

func (l LogCtx) Fatalf(template string, args ...any) <span class="cov0" title="0">{
        if !l.log.Enabled(l.ctx, slog.LevelError) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var pcs [1]uintptr
        runtime.Callers(2, pcs[:])
        _ = l.log.Handler().Handle(l.ctx, slog.NewRecord(time.Now(), slog.LevelError, fmt.Sprintf(template, args...), pcs[0]))
        os.Exit(1)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package migrate

import (
        "errors"
        "fmt"
        "time"

        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

const (
        defaultAttempts = 10
        defaultTimeout  = time.Second
)

func Migrate(dsn, sourceUrl string) error <span class="cov0" title="0">{
        var (
                attempts = defaultAttempts
                m        *migrate.Migrate
                err      error
        )

        for attempts &gt; 0 </span><span class="cov0" title="0">{
                m, err = migrate.New(sourceUrl, dsn)
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">time.Sleep(defaultTimeout)
                attempts--</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("migrate.New: %w", err)
        }</span>

        <span class="cov0" title="0">if m == nil </span><span class="cov0" title="0">{
                return errors.New("migrate: migrate is nil")
        }</span>

        <span class="cov0" title="0">err = m.Up()
        defer func(m *migrate.Migrate) </span><span class="cov0" title="0">{ _, _ = m.Close() }</span>(m)

        <span class="cov0" title="0">if err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                return fmt.Errorf("migrate.Up: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package postgres

import (
        "context"
        "fmt"
        "time"

        "github.com/jackc/pgx/v5"

        "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
)

type Option func(*options)

type options struct {
        maxOpenConns    int
        maxIdleConns    int
        connMaxLifetime time.Duration
        connIdleTime    time.Duration
}

func defaultOptions() *options <span class="cov0" title="0">{
        return &amp;options{
                maxOpenConns:    5,
                maxIdleConns:    5,
                connMaxLifetime: 5 * time.Minute,
                connIdleTime:    5 * time.Minute,
        }
}</span>

func WithMaxOpenConns(n int) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.maxOpenConns = n
        }</span>
}

func WithMaxIdleConns(n int) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.maxIdleConns = n
        }</span>
}

func WithConnMaxLifetime(d time.Duration) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.connMaxLifetime = d
        }</span>
}

func WithConnIdleTime(d time.Duration) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.connIdleTime = d
        }</span>
}

func MustNew(dsn string, opts ...Option) *sqlx.DB <span class="cov0" title="0">{
        db, err := New(dsn, opts...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return db</span>
}

func New(dsn string, opts ...Option) (*sqlx.DB, error) <span class="cov0" title="0">{
        o := defaultOptions()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(o)
        }</span>

        <span class="cov0" title="0">pgxConfig, err := pgx.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid DSN: %w", err)
        }</span>

        <span class="cov0" title="0">stdlibConnector := stdlib.OpenDB(*pgxConfig)
        db := sqlx.NewDb(stdlibConnector, "pgx")

        db.SetMaxOpenConns(o.maxOpenConns)
        db.SetMaxIdleConns(o.maxIdleConns)
        db.SetConnMaxLifetime(o.connMaxLifetime)

        if setIdleTime := interface{}(db.DB).(interface {
                SetConnMaxIdleTime(d time.Duration)
        }); setIdleTime != nil </span><span class="cov0" title="0">{
                setIdleTime.SetConnMaxIdleTime(o.connIdleTime)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not ping database: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
