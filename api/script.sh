# scripts/gen_paths.sh
#!/usr/bin/env bash
set -euo pipefail

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT"

PATHS_DIR="$ROOT/api/paths"
GEN_BASE_DIR="$ROOT/internal/generated/api"

mkdir -p "$GEN_BASE_DIR"

PKG_NAMES=()
PKG_IMPORTS=()
FIELD_NAMES=()

to_pascal() {
  local s="$1"
  s="${s//[^a-zA-Z0-9_]/_}"
  local out=""
  local IFS=_
  read -ra parts <<< "$s"
  for p in "${parts[@]}"; do
    [[ -z "$p" ]] && continue
    local first; first=$(printf '%s' "$p" | cut -c1 | tr '[:lower:]' '[:upper:]')
    local rest;  rest=$(printf '%s' "$p" | cut -c2-)
    out+="$first$rest"
  done
  printf '%s' "$out"
}

# Найти все .yaml/.yml в paths рекурсивно
while IFS= read -r spec; do
  rel="${spec#${PATHS_DIR}/}"
  rel_dir="$(dirname "$rel")"
  sub="$(basename "$rel_dir")"
  base="$(basename "$spec")"
  name="${base%.*}"

  pkg="${sub}_${name}"
  pkg="${pkg//-/_}"
  pkg="${pkg//./_}"
  pkg="$(echo "$pkg" | tr '[:upper:]' '[:lower:]')"
  [[ "$pkg" =~ ^[0-9] ]] && pkg="p_${pkg}"

  out_dir="$GEN_BASE_DIR/$pkg"
  mkdir -p "$out_dir"

  cfg="$(mktemp -t oapi-conf-XXXX.yaml)"
  {
    echo "package: $pkg"
    echo "output: internal/generated/api/$pkg/handler.gen.go"
    echo
    echo "generate:"
    echo "  strict-server: true"
    echo "  models: true"
    echo "  chi-server: true"
    if [[ "${SKIP_PRUNE:-0}" == "1" ]]; then
      echo
      echo "output-options:"
      echo "  skip-prune: true"
    fi
  } > "$cfg"

  echo "→ Generating: $spec  →  $out_dir  (package $pkg)"
  go tool oapi-codegen -config "$cfg" "$spec"
  rm -f "$cfg"

  # накапливаем данные для агрегатора
  PKG_NAMES+=("$pkg")
  PKG_IMPORTS+=("github.com/yasonofriychuk/tinvest-balancer/internal/generated/api/$pkg")
  FIELD_NAMES+=("$(to_pascal "$pkg")")
done < <(find "$PATHS_DIR" -type f \( -name '*.yaml' -o -name '*.yml' \) | sort)

# типобезопасный агрегатор Routers
ROUTERS_FILE="$GEN_BASE_DIR/routers.gen.go"
{
  cat <<'EOF'
// Code generated by scripts/gen_paths.sh; DO NOT EDIT.

package api

import (
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
EOF
  # импорты подпакетов
  for i in "${!PKG_NAMES[@]}"; do
    echo "	${PKG_NAMES[$i]} \"${PKG_IMPORTS[$i]}\""
  done
  cat <<'EOF'
)
EOF

  echo
  echo "// Routers собирает реализации StrictServerInterface по каждому сгенерированному подпакету."
  echo "type Routers struct {"
  for i in "${!PKG_NAMES[@]}"; do
    echo "	${FIELD_NAMES[$i]} ${PKG_NAMES[$i]}.StrictServerInterface"
  done
  echo "}"

  cat <<'EOF'

 // Register регистрирует все непустые реализации на роутере.
 func (rs Routers) Register(r chi.Router, mws []nethttp.StrictHTTPMiddlewareFunc) {
EOF
  for i in "${!PKG_NAMES[@]}"; do
    echo "	if rs.${FIELD_NAMES[$i]} != nil {"
    echo "		${PKG_NAMES[$i]}.HandlerFromMux(${PKG_NAMES[$i]}.NewStrictHandler(rs.${FIELD_NAMES[$i]}, mws), r)"
    echo "	}"
  done
  echo "}"
} > "$ROUTERS_FILE"

gofmt -w "$ROUTERS_FILE"
echo "→ Wrote aggregator: $ROUTERS_FILE"
echo "✓ Done."
